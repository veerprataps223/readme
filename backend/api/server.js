import express from "express";
import fetch from "node-fetch";
import dotenv from "dotenv";
import cors from "cors";

dotenv.config();
const app = express();

app.use(express.json({ limit: '10mb' }));
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:5173'],
  credentials: true
}));

const PORT = process.env.PORT || 5000;
const GITHUB_API = "https://api.github.com";
const GEMINI_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent";

// Test Gemini API connection
async function testGeminiAPI() {
  if (!process.env.GEMINI_API_KEY) {
    console.log('âŒ No Gemini API key found');
    return { success: false, error: 'No API key' };
  }

  try {
    console.log('\nðŸ§ª Testing Gemini 2.0 Flash API...');
    const response = await fetch(`${GEMINI_API}?key=${process.env.GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: "Hello! Please respond with 'Gemini 2.0 Flash API is working!' to confirm the connection."
          }]
        }]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.log('âŒ Gemini API error:', response.status, errorText);
      return { success: false, error: `HTTP ${response.status}: ${errorText}` };
    }

    const data = await response.json();
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    
    console.log('âœ… Gemini 2.0 Flash API Response:', generatedText);
    return { success: true, response: generatedText };
    
  } catch (error) {
    console.log('âŒ Gemini API test failed:', error.message);
    return { success: false, error: error.message };
  }
}

// Clean markdown response by removing first 12 characters and closing backticks
function cleanMarkdownResponse(text) {
  if (!text) return '';

  let cleaned = text.trim();

  // Remove opening ```markdown or ``` if present
  cleaned = cleaned.replace(/^```(?:markdown)?\s*/i, '');

  // Remove closing ```
  cleaned = cleaned.replace(/```$/, '').trim();

  return cleaned;
}


// Generate README using Gemini API
async function generateReadmeWithGemini(repoInfo, files, repoData) {
  if (!process.env.GEMINI_API_KEY) {
    throw new Error('Gemini API key not configured');
  }

  // Analyze file content for context
  const fileAnalysis = analyzeFiles(files);
  
  const prompt = `You are a technical documentation expert. Generate a comprehensive, professional README.md for this GitHub repository:

**Repository:** ${repoData.full_name}
**Description:** ${repoData.description || 'No description provided'}
**Language:** ${repoData.language || 'Not specified'}
**Stars:** ${repoData.stargazers_count || 0}
**Files Analysis:**
${fileAnalysis}

**Requirements:**
1. Create a complete, professional README.md
2. Include appropriate sections: Title(Title should be bolder and bigger or should look different than other headings), Description, Features, Usage, Installation,tech stack etc.
3. You can go a little more aggressive or deep within description , usage and features
4. Make sure chronological order is title , description, features, usage, tech stack, installation and other things etc...
4. Add relevant badges if applicable
5. Include code examples if you can infer usage patterns
6. Make it engaging and informative
7. Use proper Markdown formatting
8. Keep it concise but comprehensive

CRITICAL: Return ONLY raw markdown content. Do NOT wrap it in code blocks. Do NOT use \`\`\`markdown. Start directly with # title. No code fences whatsoever.`;

  try {
    const response = await fetch(`${GEMINI_API}?key=${process.env.GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 2048,
        }
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    const generatedReadme = data.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!generatedReadme) {
      throw new Error('No content generated by Gemini API');
    }

    // Clean the response to remove any markdown code block wrappers
    const cleanedReadme = cleanMarkdownResponse(generatedReadme);
    
    console.log('ðŸ§¹ Cleaned markdown response (removed code block wrappers)');
    
    return cleanedReadme;
    
  } catch (error) {
    console.error('Gemini API generation failed:', error.message);
    throw error;
  }
}

// Analyze files to provide context to Gemini
function analyzeFiles(files) {
  const analysis = {
    totalFiles: files.length,
    languages: new Set(),
    frameworks: new Set(),
    hasTests: false,
    hasDocker: false,
    hasCICD: false,
    hasReadme: false,
    configFiles: [],
    mainFiles: []
  };

  files.forEach(file => {
    const name = file.name.toLowerCase();
    const ext = name.split('.').pop();
    
    // Language detection
    const langMap = {
      'js': 'JavaScript', 'ts': 'TypeScript', 'py': 'Python', 'java': 'Java',
      'cpp': 'C++', 'c': 'C', 'rb': 'Ruby', 'php': 'PHP', 'go': 'Go',
      'rs': 'Rust', 'swift': 'Swift', 'kt': 'Kotlin', 'scala': 'Scala'
    };
    if (langMap[ext]) analysis.languages.add(langMap[ext]);

    // Framework detection
    if (name === 'package.json') analysis.frameworks.add('Node.js');
    if (name === 'requirements.txt' || name === 'setup.py') analysis.frameworks.add('Python');
    if (name === 'pom.xml' || name === 'build.gradle') analysis.frameworks.add('Java');
    if (name === 'cargo.toml') analysis.frameworks.add('Rust');
    if (name === 'go.mod') analysis.frameworks.add('Go');

    // Special files
    if (name.includes('test') || name.includes('spec')) analysis.hasTests = true;
    if (name === 'dockerfile' || name === 'docker-compose.yml') analysis.hasDocker = true;
    if (name.includes('ci') || name.includes('workflow') || name === '.travis.yml') analysis.hasCICD = true;
    if (name === 'readme.md') analysis.hasReadme = true;

    // Important files
    if (['package.json', 'requirements.txt', 'cargo.toml', 'go.mod', 'pom.xml'].includes(name)) {
      analysis.configFiles.push(file.name);
    }
    if (['index.js', 'main.py', 'app.js', 'server.js', 'main.go'].includes(name)) {
      analysis.mainFiles.push(file.name);
    }
  });

  return `
- Total files: ${analysis.totalFiles}
- Languages: ${Array.from(analysis.languages).join(', ') || 'Unknown'}
- Frameworks: ${Array.from(analysis.frameworks).join(', ') || 'None detected'}
- Has tests: ${analysis.hasTests ? 'Yes' : 'No'}
- Has Docker: ${analysis.hasDocker ? 'Yes' : 'No'}
- Has CI/CD: ${analysis.hasCICD ? 'Yes' : 'No'}
- Config files: ${analysis.configFiles.join(', ') || 'None'}
- Main files: ${analysis.mainFiles.join(', ') || 'None'}
- Key files found: ${files.slice(0, 10).map(f => f.name).join(', ')}`;
}

// Debug function to check GitHub API status
async function checkGitHubRateLimit() {
  const headers = { 
    "User-Agent": "readme-generator-debug",
    "Accept": "application/vnd.github.v3+json"
  };
  
  if (process.env.GITHUB_TOKEN) {
    headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
  }

  try {
    const res = await fetch(`${GITHUB_API}/rate_limit`, { headers });
    const data = await res.json();
    
    console.log('\nðŸ” GitHub API Rate Limit Status:');
    console.log(`- Core API: ${data.resources.core.remaining}/${data.resources.core.limit} remaining`);
    console.log(`- Reset time: ${new Date(data.resources.core.reset * 1000).toLocaleTimeString()}`);
    console.log(`- Authentication: ${process.env.GITHUB_TOKEN ? 'âœ… Using token' : 'âŒ Unauthenticated'}\n`);
    
    return data;
  } catch (error) {
    console.error('âŒ Failed to check rate limit:', error.message);
    return null;
  }
}

// Fetch repository files
async function fetchRepoFiles(owner, repo, path = "", depth = 0) {
  if (depth > 2) return []; // Limit depth to prevent too many requests
  
  const url = `${GITHUB_API}/repos/${owner}/${repo}/contents/${path}`;
  const headers = { 
    "User-Agent": "readme-generator",
    "Accept": "application/vnd.github.v3+json"
  };
  
  if (process.env.GITHUB_TOKEN) {
    headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
  }

  try {
    const res = await fetch(url, { headers, timeout: 10000 });
    
    if (!res.ok) {
      if (res.status === 403) {
        const rateLimitReset = res.headers.get('x-ratelimit-reset');
        const resetTime = new Date(parseInt(rateLimitReset) * 1000);
        throw new Error(`Rate limit exceeded. Resets at: ${resetTime.toLocaleTimeString()}`);
      } else if (res.status === 404) {
        throw new Error("Repository not found or path doesn't exist");
      }
      const errorText = await res.text();
      throw new Error(`GitHub API error: ${res.status} - ${errorText}`);
    }
    
    const items = await res.json();
    if (!Array.isArray(items)) return [];
    
    let files = [];
    for (const item of items.slice(0, 30)) { // Limit items
      if (item.type === "file") {
        files.push({
          name: item.name,
          path: item.path,
          size: item.size || 0,
          download_url: item.download_url
        });
      } else if (item.type === "dir" && depth < 1) {
        // Only go one level deep for now
        const subFiles = await fetchRepoFiles(owner, repo, item.path, depth + 1);
        files = files.concat(subFiles);
      }
    }
    
    return files;
    
  } catch (error) {
    console.error(`âŒ Error fetching files from ${path}:`, error.message);
    if (depth === 0) throw error;
    return [];
  }
}

// Parse GitHub URL
function parseGitHubUrl(url) {
  const patterns = [
    /github\.com\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/,
    /^([^\/\s]+)\/([^\/\s]+)$/
  ];
  
  for (const pattern of patterns) {
    const match = url.trim().match(pattern);
    if (match) {
      return { owner: match[1], repo: match[2] };
    }
  }
  return null;
}

// Test endpoint for Gemini API
app.get("/test-gemini", async (req, res) => {
  try {
    console.log('\n' + '='.repeat(50));
    console.log('ðŸ¤– Testing Gemini 2.0 Flash API Connection');
    console.log('='.repeat(50));
    
    const result = await testGeminiAPI();
    
    res.json({
      success: result.success,
      message: result.success ? "Gemini 2.0 Flash API is working!" : "Gemini API test failed",
      model: "gemini-2.0-flash-exp",
      response: result.response || null,
      error: result.error || null,
      hasApiKey: !!process.env.GEMINI_API_KEY,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Test failed",
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Enhanced main endpoint with Gemini integration
app.post("/generate-readme", async (req, res) => {
  try {
    console.log('\n' + '='.repeat(50));
    console.log('ðŸš€ README Generation Started (Gemini 2.0 Flash)');
    console.log('='.repeat(50));
    
    const { repoUrl } = req.body;
    
    if (!repoUrl) {
      return res.status(400).json({ error: "Repository URL is required" });
    }

    // Check rate limit before starting
    const rateLimitInfo = await checkGitHubRateLimit();
    if (rateLimitInfo && rateLimitInfo.resources.core.remaining < 5) {
      const resetTime = new Date(rateLimitInfo.resources.core.reset * 1000);
      return res.status(429).json({ 
        error: `Rate limit nearly exceeded. Try again after ${resetTime.toLocaleTimeString()}` 
      });
    }

    // Parse GitHub URL
    const repoInfo = parseGitHubUrl(repoUrl);
    if (!repoInfo) {
      return res.status(400).json({ 
        error: "Invalid GitHub URL format. Use: https://github.com/owner/repository" 
      });
    }

    // Get repository data
    console.log(`\nðŸ“¡ Fetching repository: ${repoInfo.owner}/${repoInfo.repo}`);
    const repoResponse = await fetch(`${GITHUB_API}/repos/${repoInfo.owner}/${repoInfo.repo}`, {
      headers: {
        "User-Agent": "readme-generator",
        "Accept": "application/vnd.github.v3+json",
        ...(process.env.GITHUB_TOKEN && { Authorization: `Bearer ${process.env.GITHUB_TOKEN}` })
      }
    });

    if (!repoResponse.ok) {
      if (repoResponse.status === 404) {
        return res.status(404).json({ error: "Repository not found or is private" });
      }
      throw new Error(`GitHub API error: ${repoResponse.status}`);
    }

    const repoData = await repoResponse.json();
    console.log(`âœ… Repository found: ${repoData.full_name}`);

    // Fetch files
    console.log('ðŸ“ Fetching repository files...');
    const files = await fetchRepoFiles(repoInfo.owner, repoInfo.repo);
    
    if (files.length === 0) {
      throw new Error("No accessible files found in repository");
    }

    console.log(`ðŸ“„ Found ${files.length} files`);

    // Generate README with Gemini 2.0 Flash
    console.log('ðŸ¤– Generating README with Gemini 2.0 Flash AI...');
    const readme = await generateReadmeWithGemini(repoInfo, files, repoData);

    // File analysis for response
    const fileAnalysis = analyzeFiles(files);
    const analysis = {
      mainLanguage: repoData.language || Array.from(new Set(files.map(f => {
        const ext = f.name.split('.').pop();
        const langMap = { 'js': 'JavaScript', 'ts': 'TypeScript', 'py': 'Python' };
        return langMap[ext];
      }).filter(Boolean)))[0] || "Unknown",
      languages: Array.from(new Set(files.map(f => {
        const ext = f.name.split('.').pop();
        const langMap = { 'js': 'JavaScript', 'ts': 'TypeScript', 'py': 'Python', 'java': 'Java' };
        return langMap[ext];
      }).filter(Boolean))),
      totalFiles: files.length,
      analyzedFiles: files.length,
      hasTests: files.some(f => f.name.toLowerCase().includes('test')),
      hasDocker: files.some(f => f.name.toLowerCase() === 'dockerfile'),
      hasCICD: files.some(f => f.name.includes('ci') || f.name.includes('workflow'))
    };

    console.log('âœ… Enhanced README generated successfully with deep analysis');
    
    res.json({
      readme,
      analysis: {
        ...analysis,
        deepAnalysis: {
          projectType: 'Enhanced analysis completed',
          tokensUsed: 'Up to 8192 tokens',
          enhancedFeatures: [
            'File content analysis',
            'Dependency detection', 
            'API endpoint discovery',
            'Architecture insights',
            'Deployment guidance'
          ]
        }
      },
      model: "gemini-2.0-flash-exp",
      repository: {
        name: repoData.full_name,
        description: repoData.description,
        stars: repoData.stargazers_count,
        language: repoData.language
      }
    });

  } catch (error) {
    console.error('\nâŒ Generation failed:', error.message);
    
    if (error.message.includes('Rate limit')) {
      res.status(429).json({ error: error.message });
    } else if (error.message.includes('not found')) {
      res.status(404).json({ error: "Repository not found or is private" });
    } else if (error.message.includes('Gemini')) {
      res.status(500).json({ error: `AI Generation failed: ${error.message}` });
    } else {
      res.status(500).json({ error: error.message });
    }
  }
});

// Health check with both GitHub and Gemini API tests
app.get("/health", async (req, res) => {
  try {
    const [rateLimitInfo, geminiTest] = await Promise.all([
      checkGitHubRateLimit(),
      testGeminiAPI()
    ]);
    
    res.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      environment: {
        hasGeminiKey: !!process.env.GEMINI_API_KEY,
        hasGithubToken: !!process.env.GITHUB_TOKEN,
        nodeVersion: process.version,
        port: PORT
      },
      github: {
        rateLimitRemaining: rateLimitInfo?.resources.core.remaining || 'unknown',
        rateLimitTotal: rateLimitInfo?.resources.core.limit || 'unknown',
        status: rateLimitInfo ? 'connected' : 'error'
      },
      gemini: {
        model: "gemini-2.0-flash-exp",
        status: geminiTest.success ? 'connected' : 'error',
        error: geminiTest.error || null
      }
    });
  } catch (error) {
    res.status(500).json({
      status: "unhealthy",
      error: error.message
    });
  }
});

app.listen(PORT, async () => {
  console.log(`ðŸš€ Enhanced Server running on http://localhost:${PORT}`);
  console.log(`ðŸ“Š Health check: http://localhost:${PORT}/health`);
  console.log(`ðŸ¤– Test Gemini 2.0 Flash: GET http://localhost:${PORT}/test-gemini`);
  console.log(`ðŸ”‘ GitHub Token: ${process.env.GITHUB_TOKEN ? 'âœ…' : 'âŒ'}`);
  console.log(`ðŸ”‘ Gemini Key: ${process.env.GEMINI_API_KEY ? 'âœ…' : 'âŒ'}`);
  console.log(`ðŸ”¥ Using Gemini 2.0 Flash model`);
  
  // Test both APIs on startup
  setTimeout(async () => {
    await checkGitHubRateLimit();
    await testGeminiAPI();
  }, 1000);
});